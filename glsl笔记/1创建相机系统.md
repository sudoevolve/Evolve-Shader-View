# GLSL相机系统学习笔记

## 基础概念

### Shadertoy特殊变量
```glsl
// fragCoord: 当前处理的像素坐标 (x,y)
// iResolution: 屏幕分辨率 (宽度,高度)
// iTime: 程序运行时间(秒)
// mainImage: 主函数，Shadertoy要求的格式
```

### 变量类型
- `vec2`: 包含2个数字 (x,y)
- `vec3`: 包含3个数字 (x,y,z) 或 (r,g,b)
- `vec4`: 包含4个数字 (x,y,z,w) 或 (r,g,b,a)

## UV坐标系统

### UV的含义
- **U**: 水平方向坐标 (类似X轴)
- **V**: 垂直方向坐标 (类似Y轴)
- 范围: 0.0 到 1.0 (标准化坐标)

### 坐标转换
```glsl
// 从像素坐标转换到标准化坐标
vec2 uv = fragCoord / iResolution.xy;  // 范围[0,1]
uv = uv * 2.0 - 1.0;                   // 范围[-1,1]
uv.x = uv.x * (iResolution.x / iResolution.y);  // 修正宽高比
```

## 相机系统

### 相机三要素
```glsl
vec3 cameraPosition = vec3(0.0, 0.0, -5.0);  // 相机位置
vec3 lookAtPoint = vec3(0.0, 0.0, 0.0);      // 目标点
vec3 cameraUp = vec3(0.0, 1.0, 0.0);         // 上方向
```

### 3D坐标系
```
          ↑ Y(上)
          |
    (-)   |   (+)
          |
----------+----------→ X(右)
          |
    (-)   |   (+)   
          |
          ↓ Z(前)
```

## 相机坐标系计算

### 第一步：计算forward方向
```glsl
vec3 forward = normalize(lookAtPoint - cameraPosition);
```
- **原理**: 从当前位置指向目标位置的方向
- **比喻**: "从我家到超市应该朝哪个方向走？"
- **计算**: B点 - A点 = 从A到B的方向

### 第二步：计算right方向
```glsl
vec3 right = normalize(cross(forward, cameraUp));
```
- **原理**: 使用叉积计算垂直方向
- **比喻**: 右手定则 - 食指前，中指上，拇指右
- **叉积**: cross(A,B) = 同时垂直于A和B的向量

### 第三步：计算up方向
```glsl
vec3 up = normalize(cross(right, forward));
```
- **原理**: 重新计算确保真正的垂直方向
- **目的**: 保证三个方向互相垂直，形成标准坐标系

## 叉积计算公式

### 叉积定义
```glsl
// cross((ax,ay,az), (bx,by,bz)) = 
// (ay*bz - az*by, az*bx - ax*bz, ax*by - ay*bx)
```

### 实例计算
```glsl
// forward = (0,0,1), cameraUp = (0,1,0)
// cross((0,0,1), (0,1,0)) =
// (0*0 - 1*1, 1*0 - 0*0, 0*1 - 0*0)
// = (-1, 0, 0)
```

## 完整示例代码

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // 1. 坐标转换
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv * 2.0 - 1.0;
    uv.x = uv.x * (iResolution.x / iResolution.y);
    
    // 2. 相机设置
    vec3 cameraPos = vec3(0.0, 0.0, -5.0);
    vec3 lookAt = vec3(0.0, 0.0, 0.0);
    vec3 cameraUp = vec3(0.0, 1.0, 0.0);
    
    // 3. 计算相机坐标系
    vec3 forward = normalize(lookAt - cameraPos);
    vec3 right = normalize(cross(forward, cameraUp));
    vec3 up = normalize(cross(right, forward));
    
    // 4. 计算射线方向
    vec3 rayDir = normalize(uv.x * right + uv.y * up + forward * 2.0);
    
    // 5. 输出颜色
    vec3 color = vec3(0.5, 0.5, 1.0);
    fragColor = vec4(color, 1.0);
}
```

## 关键概念总结

### 变量 vs 函数
- **变量**: 存储数据的"容器" (如 cameraPosition)
- **函数**: 执行操作的"机器" (如 mainImage())

### 3D vs 2D
- **3D世界**: 无限大，坐标可以是任何值
- **2D屏幕**: 有限区域，坐标受分辨率限制

### 标准化的重要性
- **normalize()**: 将向量长度变为1，只保留方向
- **用途**: 确保计算的一致性和准确性