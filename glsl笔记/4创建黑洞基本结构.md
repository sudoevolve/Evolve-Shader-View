//基础假黑洞


// ==== 可调节参数 ====

// 黑洞
#define BH_MASS 1.5                // 黑洞质量 (影响光线弯曲)
#define BH_RADIUS 0.5              // 黑洞施瓦西半径
#define BH_POS vec3(0.0)           // 黑洞位置

// 吸积盘
#define DISK_HEIGHT 0.01            // 盘厚度
#define DISK_INNER 0.6             // 吸积盘内径 (倍数 * BH_RADIUS)
#define DISK_OUTER 5.0             // 吸积盘外径 (倍数 * BH_RADIUS)
#define DISK_STEP 0.05             // 体积步长 (越小越细腻，越耗性能)
#define DISK_DIST 6.0              // 光线最大追踪距离
#define DISK_DENSITY 2.0           // 吸积盘密度系数
#define DISK_COLOR1 vec3(1.0,0.5,0.2) // 吸积盘主色 (橙色)
#define DISK_COLOR2 vec3(1.0,0.9,0.6) // 吸积盘副色 (浅黄)

// 光子球 (光圈)
#define PHOTON_SPHERE 1.5          // 光子球半径 (倍数 * BH_RADIUS)
#define PHOTON_GLOW_SIZE 0.01      // 光晕厚度 (调小光圈收缩)
#define PHOTON_GLOW_INTENSITY 3.0  // 光晕亮度 (调低避免太大)

// 星空
#define STAR_THRESHOLD 0.995       // 星星数量阈值
#define STAR_INTENSITY 1.0         // 星星亮度


// ==== 随机数与噪声 ====
float hash3D(vec3 p) {
    return fract(sin(dot(p, vec3(12.9898, 78.233, 37.719))) * 43758.5453);
}

float noise(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    f = f*f*(3.0-2.0*f);
    float n = mix(mix(mix(hash3D(i+vec3(0,0,0)), hash3D(i+vec3(1,0,0)), f.x),
                     mix(hash3D(i+vec3(0,1,0)), hash3D(i+vec3(1,1,0)), f.x), f.y),
                 mix(mix(hash3D(i+vec3(0,0,1)), hash3D(i+vec3(1,0,1)), f.x),
                     mix(hash3D(i+vec3(0,1,1)), hash3D(i+vec3(1,1,1)), f.x), f.z), f.z);
    return n;
}

// ==== 星空背景 ====
vec3 starField(vec3 dir) {
    vec3 color = vec3(0.0);
    for(float i = 0.0; i < 3.0; i++) {
        vec3 gridPos = floor(dir * exp2(i) * 10.0);
        float n = hash3D(gridPos);
        if(n > STAR_THRESHOLD) {
            float brightness = pow(n, 6.0) * STAR_INTENSITY;

            // 🌟 新增：计算当前方向与最近格点中心的偏移，用于软化边缘
            vec3 center = gridPos + vec3(0.5); // 格点中心
            vec3 worldDir = dir * exp2(i) * 10.0;
            vec3 offset = worldDir - center; // 偏离中心的距离
            float distToCenter = length(offset);

            // 使用高斯衰减：越靠近格点中心越亮，边缘柔和
            float glow = exp(-distToCenter * distToCenter * 8.0); // 调整 8.0 控制光晕大小
            brightness *= glow;

            float colorType = hash3D(gridPos + vec3(123.4, 567.8, 901.2));
            if(colorType > 0.8) color += vec3(0.8, 0.8, 1.0) * brightness;
            else if(colorType > 0.6) color += vec3(1.0, 0.9, 0.7) * brightness;
            else if(colorType > 0.4) color += vec3(1.0, 0.7, 0.7) * brightness;
            else color += vec3(1.0) * brightness;
        }
    }
    return color;
}

// ==== 黑洞相交 ====
bool hitsBlackHole(vec3 ro, vec3 rd, vec3 center, float radius) {
    vec3 oc = ro - center;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float h = b*b - c;
    return (h > 0.0);
}

// ==== 光线偏折 ====
vec3 lensDistortion(vec3 ro, vec3 rd, vec3 bhPos, float mass) {
    vec3 toBH = bhPos - ro;
    float t = dot(toBH, rd);
    vec3 closestPoint = ro + rd * t;
    float r = length(bhPos - closestPoint);
    r = max(r, 0.001);

    float deflection = mass / r * 0.2; 
    vec3 bendDir = normalize(bhPos - closestPoint);
    rd = normalize(mix(rd, bendDir, deflection));
    return rd;
}

// ==== 吸积盘体积渲染 ====
vec3 renderAccretionDisk(vec3 ro, vec3 rd, vec3 bhPos, float Rs) {
    vec3 col = vec3(0.0);
    float T = 1.0;               

    for(float t=0.0; t<DISK_DIST; t+=DISK_STEP) {
        vec3 pos = ro + rd * t;
        vec3 rel = pos - bhPos;
        float r = length(rel.xz);   
        float y = rel.y;

        if(abs(y) < DISK_HEIGHT && r > DISK_INNER*Rs && r < DISK_OUTER*Rs) {
            float density = DISK_DENSITY / (r*r + 0.5);
            density *= 0.5 + 0.5*noise(pos*3.0);

            float absorb = exp(-density * DISK_STEP * 2.0);
            T *= absorb;

            vec3 baseCol = mix(DISK_COLOR1, DISK_COLOR2, noise(pos*2.0));
            col += T * density * baseCol * 2.0;

            if(T < 0.01) break;
        }
    }

    // 光子球 (缩小光晕)
    float rPhoton = PHOTON_SPHERE * Rs;
    float photonGlow = exp(-pow((length(ro.xz) - rPhoton)/PHOTON_GLOW_SIZE, 2.0));
    col += vec3(1.0,0.8,0.4) * photonGlow * PHOTON_GLOW_INTENSITY;

    return col;
}

// ==== 主函数 ====
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec3 color = vec3(0.0);
    int samples = 16; // 4x4 抗锯齿采样
    for(int sy = 0; sy < 4; sy++) {
        for(int sx = 0; sx < 4; sx++) {
            vec2 offset = vec2(float(sx) + 0.5, float(sy) + 0.5) / 4.0;
            vec2 fragCoordJittered = fragCoord + offset;

            vec2 uv = (fragCoordJittered / iResolution.xy) * 2.0 - 1.0;
            uv.x *= iResolution.x / iResolution.y;

            // 相机旋转
            vec2 mouse = (iMouse.z > 0.0) ? iMouse.xy / iResolution.xy : vec2(0.5,0.5);
            float angleX = (mouse.y - 0.5) * 3.14159;   
            float angleY = (mouse.x - 0.5) * 6.28318;   

            vec3 ro = vec3(0.0, 0.0, -3.0); 
            vec3 rd = normalize(vec3(uv, 1.5));

            mat3 rotX = mat3(1,0,0,
                             0,cos(angleX),-sin(angleX),
                             0,sin(angleX), cos(angleX));
            mat3 rotY = mat3(cos(angleY),0,sin(angleY),
                             0,1,0,
                             -sin(angleY),0,cos(angleY));
            rd = rotY * rotX * rd;
            ro = rotY * rotX * ro;

            // 黑洞参数
            float Rs = BH_RADIUS;

            // 黑洞影子
            if(hitsBlackHole(ro, rd, BH_POS, Rs)) {
                color += vec3(0.0);
                continue;
            }

            // 光线偏折
            rd = lensDistortion(ro, rd, BH_POS, BH_MASS);

            // 背景
            vec3 bgCol;
            vec2 texUV = rd.xy * 0.5 + 0.5;
            vec4 texSample = texture(iChannel0, texUV);

            if(texSample.r > 0.001 || texSample.g > 0.001 || texSample.b > 0.001) {
                bgCol = texSample.rgb;
            } else {
                bgCol = vec3(0.0, 0.0, 0.02) + starField(rd);
            }

            // 吸积盘
            vec3 diskCol = renderAccretionDisk(ro, rd, BH_POS, Rs);
            color += bgCol + diskCol;
        }
    }
    color /= float(samples);
    fragColor = vec4(color, 1.0);
}