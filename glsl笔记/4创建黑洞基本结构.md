//åŸºç¡€å‡é»‘æ´


// ==== å¯è°ƒèŠ‚å‚æ•° ====

// é»‘æ´
#define BH_MASS 1.5                // é»‘æ´è´¨é‡ (å½±å“å…‰çº¿å¼¯æ›²)
#define BH_RADIUS 0.5              // é»‘æ´æ–½ç“¦è¥¿åŠå¾„
#define BH_POS vec3(0.0)           // é»‘æ´ä½ç½®

// å¸ç§¯ç›˜
#define DISK_HEIGHT 0.01            // ç›˜åšåº¦
#define DISK_INNER 0.6             // å¸ç§¯ç›˜å†…å¾„ (å€æ•° * BH_RADIUS)
#define DISK_OUTER 5.0             // å¸ç§¯ç›˜å¤–å¾„ (å€æ•° * BH_RADIUS)
#define DISK_STEP 0.05             // ä½“ç§¯æ­¥é•¿ (è¶Šå°è¶Šç»†è…»ï¼Œè¶Šè€—æ€§èƒ½)
#define DISK_DIST 6.0              // å…‰çº¿æœ€å¤§è¿½è¸ªè·ç¦»
#define DISK_DENSITY 2.0           // å¸ç§¯ç›˜å¯†åº¦ç³»æ•°
#define DISK_COLOR1 vec3(1.0,0.5,0.2) // å¸ç§¯ç›˜ä¸»è‰² (æ©™è‰²)
#define DISK_COLOR2 vec3(1.0,0.9,0.6) // å¸ç§¯ç›˜å‰¯è‰² (æµ…é»„)

// å…‰å­çƒ (å…‰åœˆ)
#define PHOTON_SPHERE 1.5          // å…‰å­çƒåŠå¾„ (å€æ•° * BH_RADIUS)
#define PHOTON_GLOW_SIZE 0.01      // å…‰æ™•åšåº¦ (è°ƒå°å…‰åœˆæ”¶ç¼©)
#define PHOTON_GLOW_INTENSITY 3.0  // å…‰æ™•äº®åº¦ (è°ƒä½é¿å…å¤ªå¤§)

// æ˜Ÿç©º
#define STAR_THRESHOLD 0.995       // æ˜Ÿæ˜Ÿæ•°é‡é˜ˆå€¼
#define STAR_INTENSITY 1.0         // æ˜Ÿæ˜Ÿäº®åº¦


// ==== éšæœºæ•°ä¸å™ªå£° ====
float hash3D(vec3 p) {
    return fract(sin(dot(p, vec3(12.9898, 78.233, 37.719))) * 43758.5453);
}

float noise(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    f = f*f*(3.0-2.0*f);
    float n = mix(mix(mix(hash3D(i+vec3(0,0,0)), hash3D(i+vec3(1,0,0)), f.x),
                     mix(hash3D(i+vec3(0,1,0)), hash3D(i+vec3(1,1,0)), f.x), f.y),
                 mix(mix(hash3D(i+vec3(0,0,1)), hash3D(i+vec3(1,0,1)), f.x),
                     mix(hash3D(i+vec3(0,1,1)), hash3D(i+vec3(1,1,1)), f.x), f.z), f.z);
    return n;
}

// ==== æ˜Ÿç©ºèƒŒæ™¯ ====
vec3 starField(vec3 dir) {
    vec3 color = vec3(0.0);
    for(float i = 0.0; i < 3.0; i++) {
        vec3 gridPos = floor(dir * exp2(i) * 10.0);
        float n = hash3D(gridPos);
        if(n > STAR_THRESHOLD) {
            float brightness = pow(n, 6.0) * STAR_INTENSITY;

            // ğŸŒŸ æ–°å¢ï¼šè®¡ç®—å½“å‰æ–¹å‘ä¸æœ€è¿‘æ ¼ç‚¹ä¸­å¿ƒçš„åç§»ï¼Œç”¨äºè½¯åŒ–è¾¹ç¼˜
            vec3 center = gridPos + vec3(0.5); // æ ¼ç‚¹ä¸­å¿ƒ
            vec3 worldDir = dir * exp2(i) * 10.0;
            vec3 offset = worldDir - center; // åç¦»ä¸­å¿ƒçš„è·ç¦»
            float distToCenter = length(offset);

            // ä½¿ç”¨é«˜æ–¯è¡°å‡ï¼šè¶Šé è¿‘æ ¼ç‚¹ä¸­å¿ƒè¶Šäº®ï¼Œè¾¹ç¼˜æŸ”å’Œ
            float glow = exp(-distToCenter * distToCenter * 8.0); // è°ƒæ•´ 8.0 æ§åˆ¶å…‰æ™•å¤§å°
            brightness *= glow;

            float colorType = hash3D(gridPos + vec3(123.4, 567.8, 901.2));
            if(colorType > 0.8) color += vec3(0.8, 0.8, 1.0) * brightness;
            else if(colorType > 0.6) color += vec3(1.0, 0.9, 0.7) * brightness;
            else if(colorType > 0.4) color += vec3(1.0, 0.7, 0.7) * brightness;
            else color += vec3(1.0) * brightness;
        }
    }
    return color;
}

// ==== é»‘æ´ç›¸äº¤ ====
bool hitsBlackHole(vec3 ro, vec3 rd, vec3 center, float radius) {
    vec3 oc = ro - center;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float h = b*b - c;
    return (h > 0.0);
}

// ==== å…‰çº¿åæŠ˜ ====
vec3 lensDistortion(vec3 ro, vec3 rd, vec3 bhPos, float mass) {
    vec3 toBH = bhPos - ro;
    float t = dot(toBH, rd);
    vec3 closestPoint = ro + rd * t;
    float r = length(bhPos - closestPoint);
    r = max(r, 0.001);

    float deflection = mass / r * 0.2; 
    vec3 bendDir = normalize(bhPos - closestPoint);
    rd = normalize(mix(rd, bendDir, deflection));
    return rd;
}

// ==== å¸ç§¯ç›˜ä½“ç§¯æ¸²æŸ“ ====
vec3 renderAccretionDisk(vec3 ro, vec3 rd, vec3 bhPos, float Rs) {
    vec3 col = vec3(0.0);
    float T = 1.0;               

    for(float t=0.0; t<DISK_DIST; t+=DISK_STEP) {
        vec3 pos = ro + rd * t;
        vec3 rel = pos - bhPos;
        float r = length(rel.xz);   
        float y = rel.y;

        if(abs(y) < DISK_HEIGHT && r > DISK_INNER*Rs && r < DISK_OUTER*Rs) {
            float density = DISK_DENSITY / (r*r + 0.5);
            density *= 0.5 + 0.5*noise(pos*3.0);

            float absorb = exp(-density * DISK_STEP * 2.0);
            T *= absorb;

            vec3 baseCol = mix(DISK_COLOR1, DISK_COLOR2, noise(pos*2.0));
            col += T * density * baseCol * 2.0;

            if(T < 0.01) break;
        }
    }

    // å…‰å­çƒ (ç¼©å°å…‰æ™•)
    float rPhoton = PHOTON_SPHERE * Rs;
    float photonGlow = exp(-pow((length(ro.xz) - rPhoton)/PHOTON_GLOW_SIZE, 2.0));
    col += vec3(1.0,0.8,0.4) * photonGlow * PHOTON_GLOW_INTENSITY;

    return col;
}

// ==== ä¸»å‡½æ•° ====
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec3 color = vec3(0.0);
    int samples = 16; // 4x4 æŠ—é”¯é½¿é‡‡æ ·
    for(int sy = 0; sy < 4; sy++) {
        for(int sx = 0; sx < 4; sx++) {
            vec2 offset = vec2(float(sx) + 0.5, float(sy) + 0.5) / 4.0;
            vec2 fragCoordJittered = fragCoord + offset;

            vec2 uv = (fragCoordJittered / iResolution.xy) * 2.0 - 1.0;
            uv.x *= iResolution.x / iResolution.y;

            // ç›¸æœºæ—‹è½¬
            vec2 mouse = (iMouse.z > 0.0) ? iMouse.xy / iResolution.xy : vec2(0.5,0.5);
            float angleX = (mouse.y - 0.5) * 3.14159;   
            float angleY = (mouse.x - 0.5) * 6.28318;   

            vec3 ro = vec3(0.0, 0.0, -3.0); 
            vec3 rd = normalize(vec3(uv, 1.5));

            mat3 rotX = mat3(1,0,0,
                             0,cos(angleX),-sin(angleX),
                             0,sin(angleX), cos(angleX));
            mat3 rotY = mat3(cos(angleY),0,sin(angleY),
                             0,1,0,
                             -sin(angleY),0,cos(angleY));
            rd = rotY * rotX * rd;
            ro = rotY * rotX * ro;

            // é»‘æ´å‚æ•°
            float Rs = BH_RADIUS;

            // é»‘æ´å½±å­
            if(hitsBlackHole(ro, rd, BH_POS, Rs)) {
                color += vec3(0.0);
                continue;
            }

            // å…‰çº¿åæŠ˜
            rd = lensDistortion(ro, rd, BH_POS, BH_MASS);

            // èƒŒæ™¯
            vec3 bgCol;
            vec2 texUV = rd.xy * 0.5 + 0.5;
            vec4 texSample = texture(iChannel0, texUV);

            if(texSample.r > 0.001 || texSample.g > 0.001 || texSample.b > 0.001) {
                bgCol = texSample.rgb;
            } else {
                bgCol = vec3(0.0, 0.0, 0.02) + starField(rd);
            }

            // å¸ç§¯ç›˜
            vec3 diskCol = renderAccretionDisk(ro, rd, BH_POS, Rs);
            color += bgCol + diskCol;
        }
    }
    color /= float(samples);
    fragColor = vec4(color, 1.0);
}