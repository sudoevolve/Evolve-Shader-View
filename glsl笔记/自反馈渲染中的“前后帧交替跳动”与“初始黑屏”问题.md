# 📄 解决方案文档：自反馈渲染中的“前后帧交替跳动”与“初始黑屏”问题

---

## 1. 摘要

本文档详细分析并解决在本地多通道 Shadertoy 风格渲染器中常见的两个关键问题：

- **问题 A：画面在两帧之间来回闪烁（前帧/后帧交替跳动）**
- **问题 B：程序启动时屏幕全黑，数秒后才出现内容**

这两个问题**仅出现在使用 `iChannel0 = self`（即 feedback）的 pass 中**，而普通跨 pass 引用则无此现象。

本文从 OpenGL 原理、资源管理机制和渲染流程角度深入剖析根本原因，并提供完整解决方案。

---

## 2. 问题描述

### ✅ 正常行为预期
- 使用 `iChannel0 = self` 的 shader 应能读取上一帧输出，实现残影、延迟、群体动画等效果。
- 启动后应快速初始化状态，随后流畅连续播放动画。

### ❌ 实际异常表现

| 现象 | 描述 |
|------|------|
| **A. 前后帧交替跳动** | 画面在两个不同状态间反复切换，视觉上像“闪烁”或“抖动”，仿佛每帧都在 A 和 B 之间跳跃 |
| **B. 初始黑屏** | 程序运行初期屏幕为黑色，持续数秒后突然开始渲染，且可能伴随跳动 |

> ⚠️ 这些问题**只发生在设置了 `iChannel0 = self` 的 pass 上**，其他 pass 显示正常。

---

## 3. 根本原因分析

### 🔍 问题 A：前后帧交替跳动

#### 🧩 错误设计：使用 `std::swap(id)` 管理双缓冲

原始代码采用如下逻辑进行反馈纹理更新：

```cpp
std::swap(prevFrameTextures[i].id, tempFbos[i].colorTex.id);
```

这导致：
- `prevFrameTextures[i]` 拿到了一个临时 FBO 内部的 texture ID
- 下一次 `tempFbos[i].create()` 会调用 `glDeleteTextures` 删除该 ID
- 而 `prevFrameTextures[i]` 却仍持有这个已被删除的 ID → 成为 **dangling texture handle**

OpenGL 对已删除纹理的采样行为是未定义的（通常返回 `(0,0,0,0)` 或旧数据），造成：
> 第 N 帧读的是有效数据 → 第 N+1 帧读的是空值 → 第 N+2 帧又恢复 → 视觉上形成“跳动”

📌 **本质是纹理所有权混乱 + 生命周期冲突**

---

### 🔍 问题 B：初始黑屏

#### 🧩 原因 1：未初始化反馈纹理

当 pass0 第一次执行时，它尝试从 `iChannel0`（即自身上一帧）读取数据。但此时：
- `prevFrameTextures[0]` 是空纹理或未分配
- `texelFetch(iChannel0, ...)` 返回 `(0,0,0,0)`
- 所有鱼的位置为 `(0,0)` → 物理计算崩溃（除零、log(0)）
- 导致输出无效，画面为黑

#### 🧩 原因 2：依赖 `iFrame < 5` 初始化分支，但未能触发

某些 Shadertoy shader 使用以下模式初始化：

```glsl
if (iFrame < 5) fc = random_initial_state;
else compute_physics();
```

但如果 C++ 层传入的 `iFrame` 起始值不为 0，或 feedback 链断裂，则永远不会进入初始化分支。

---

## 4. 为什么只有“自反馈 buffer”会出现这些问题？

| 问题 | 普通 Pass（非 self） | 自反馈 Pass（self） | 原因 |
|------|------------------------|-----------------------|------|
| **跳动** | ❌ 不发生 | ✅ 发生 | 只有 self 需要双缓冲循环引用 |
| **黑屏** | ❌ 不发生 | ✅ 发生 | 只有 self 依赖自己的历史状态 |

> ✅ 其他 pass 如 `buffer1 ← buffer0` 是单向依赖，不会形成闭环，因此不受影响。

---

## 5. 解决方案

### ✅ 方案总览

| 目标 | 方法 |
|------|------|
| 消除跳动 | 避免 `swap(texture.id)`，改用安全拷贝 |
| 消除黑屏 | 强制初始化第一帧状态 |
| 保证稳定 | 使用固定 ID 的高精度纹理 |

---

### ✅ 解决跳动：使用 `glCopyTexSubImage2D` 替代 `swap(id)`

#### ❌ 错误做法（导致跳动）

```cpp
std::swap(prev.id, temp.colorTex.id); // 危险！破坏纹理生命周期
```

#### ✅ 正确做法（稳定反馈链）

```cpp
// 初始化阶段创建稳定的纹理对象
for (auto& tex : prevFrameTextures) {
    glGenTextures(1, &tex.id);
    glBindTexture(GL_TEXTURE_2D, tex.id);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, w, h, 0, GL_RGBA, GL_FLOAT, nullptr);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
}
```

#### 在每帧结尾执行拷贝：

```cpp
// 将当前 FBO 输出复制到 prevFrameTextures
for (size_t i = 0; i < fbos.size(); ++i) {
    glBindTexture(GL_TEXTURE_2D, prevFrameTextures[i].id);
    glBindFramebuffer(GL_READ_FRAMEBUFFER, fbos[i].fbo);
    glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, width, height);
}
```

✅ 优点：
- `prevFrameTextures[i].id` 永远不变
- 不涉及临时资源 swap
- 完全避免 dangling handle

---

### ✅ 解决黑屏：强制初始化第一帧

添加函数，在主循环开始前手动写入初始状态：

```cpp
void InitializeFirstFrame(const GLProgram& program, Texture& destTex, int width, int height) {
    Framebuffer initFbo;
    initFbo.create(width, height);
    initFbo.bind();

    program.use();
    glUniform3f(program.getUniformLocation("iResolution"), width, height, 1.0f);
    glUniform1i(program.getUniformLocation("iFrame"), 4); // 触发 iFrame < 5 分支
    glUniform1f(program.getUniformLocation("iTime"), 0.0f);
    // 绑定空纹理防止读未定义内存
    emptyTex.bind(0);

    glClear(GL_COLOR_BUFFER_BIT);
    DrawFullScreenQuad(); // 渲染一次

    // 复制结果到 destTex
    glBindTexture(GL_TEXTURE_2D, destTex.id);
    glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, width, height);

    Framebuffer::unbind();
}
```

调用时机：

```cpp
InitializeFirstFrame(programs[0], prevFrameTextures[0], g_winWidth, g_winHeight);

while (!glfwWindowShouldClose(window)) {
    // 主循环...
}
```

---

### ✅ 补充建议

| 建议 | 说明 |
|------|------|
| 使用 `GL_RGBA32F` | 确保浮点精度，避免物理模拟漂移 |
| 设置 `NEAREST` 过滤 | `texelFetch` 要求整数坐标采样 |
| 避免 `discard` | 防止部分像素未写入导致残留 |
| 统一 `iFrame` 计数 | 所有 pass 共享同一递增计数器 |

---

## 6. 最终验证步骤

1. ✅ 运行程序，观察是否仍有“跳动”
2. ✅ 检查是否还有“黑屏”期
3. ✅ 移动鼠标查看交互是否生效
4. ✅ 查看控制台确认 feedback 已正确设置为 `self`
5. ✅ 修改窗口大小，确认纹理自动重置

---

## 7. 总结

| 问题 | 根本原因 | 解法 |
|------|----------|------|
| **前后帧跳动** | `swap(texture.id)` 导致纹理句柄失效 | 改用 `glCopyTexSubImage2D` + 固定 ID 纹理 |
| **初始黑屏** | 未初始化 feedback 纹理 | 手动调用一次初始化渲染 |
| **仅 self 出现** | 只有 feedback 形成闭环依赖 | 非 feedback pass 无此风险 |

---
